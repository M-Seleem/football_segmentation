# -*- coding: utf-8 -*-
"""football_segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/107FCOrx2nAcy5zUlcKm5E3uBJZbOZHcU
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import keras
import numpy as np
import pandas as pd
import tensorflow as tf

from glob import glob
from tqdm import tqdm
import tensorflow.image as tfi
from tensorflow.keras.utils import load_img, img_to_array

import matplotlib.pyplot as plt

from keras.layers import add
from keras.layers import Input
from keras.layers import Layer
from keras.layers import Conv2D
from keras.layers import multiply
from keras.layers import Dropout
from keras.layers import MaxPool2D
from keras.layers import Concatenate
from keras.layers import Conv2DTranspose
from keras.layers import BatchNormalization
from keras.callbacks import Callback, ModelCheckpoint
from keras.models import Model

from tensorflow.keras.utils import plot_model
from sklearn.model_selection import train_test_split
import sys
import skimage.io
import matplotlib.pyplot as plt
import cv2
import time
import numpy as np
# %matplotlib inline
import tensorflow as tf

from google.colab import drive
drive.mount('/content/gdrive')

# !unzip gdrive/My\ Drive/football_segmentation.zip

# !unzip gdrive/My\ Drive/football_segmentation.zip > /dev/null

data_path = '/content/gdrive/MyDrive/football_segmentation'

import glob
# img heya el sora
# dataset heya folder
# data_list = os.listdir(data_path)
images_path = glob.glob("/content/gdrive/MyDrive/football_segmentation/"+"*.jpg")
labels_path = [path.replace(".jpg", ".jpg___fuse.png") for path in images_path]
# print(labels_path)

images_path[0]

labels_path[0]

def load_image(path, SIZE=256):
    image = load_img(path)
    image = tfi.resize(image, (SIZE, SIZE))
    image = img_to_array(image)
    image = tf.cast(image, tf.float32)
    image = image/255.
    return image

def load_data(image_paths, label_paths, SIZE=256):
    images, label_maps = np.zeros(shape=(len(image_paths), SIZE, SIZE, 3)), np.zeros(shape=(len(label_paths), SIZE, SIZE, 3))
    for i, (image_path, label_path) in tqdm(enumerate(zip(image_paths, label_paths)), desc="Loading"):
        image, label_map = load_image(image_path, SIZE=SIZE), load_image(label_path, SIZE=SIZE)
        images[i], label_maps[i] = image, label_map
    return images, label_maps

images, label_maps = load_data(images_path, labels_path)

def show_maps(images, label_maps, GRID=[5,6], SIZE=(25,25)):

    n_rows, n_cols = GRID
    n_images = n_rows * n_cols
    plt.figure(figsize=SIZE)

    i=1
    for image, label_map in zip(images, label_maps):

        plt.subplot(n_rows, n_cols, i)

        plt.imshow(image, alpha=1)
        plt.imshow(label_map, alpha=0.7)
        plt.axis('off')

        i+=1
        if i>n_images:
            break

    plt.show()

from sklearn.model_selection import train_test_split

train_images, test_images, train_labels, test_labels = train_test_split(images,
                                                                        label_maps,
                                                                        test_size=0.2,
                                                                        random_state=42)

show_maps(train_images, train_labels)

def encoder(X, filters, rate=0.2, pooling=True):
    x = BatchNormalization()(X)
    x = Conv2D(filters, kernel_size=3, strides=1, padding='same', activation='relu',
               kernel_initializer='he_normal')(x)
    x = Dropout(rate)(x)
    x = Conv2D(filters, kernel_size=3, strides=1, padding='same', activation='relu',
               kernel_initializer='he_normal')(x)
    if pooling:
        y = MaxPool2D()(x)
        return x, y
    return x

def decoder(x, skip_x, filters, rate):
    y = Conv2DTranspose(filters, kernel_size=3, strides=2, padding='same', activation='relu',
                        kernel_initializer='he_normal')(BatchNormalization()(x))
    y = encoder(Concatenate()([y, skip_x]), filters, rate, pooling=False)
    return y

# Input Layer
InputL = Input(shape=(256, 256, 3), name="InputImage")

# Encoder Block
c1, p1 = encoder(InputL, filters=64, rate=0.1)
c2, p2 = encoder(p1, filters=128, rate=0.1)
c3, p3 = encoder(p2, filters=256, rate=0.2)
c4, p4 = encoder(p3, filters=512, rate=0.2)

# Encoding Layer
encodings = encoder(p4, filters=512, rate=0.3, pooling=False)

# Decoder Block
d = decoder(encodings, c4, filters=512, rate=0.2)
d = decoder(d, c3, filters=256, rate=0.2)
d = decoder(d, c2, filters=128, rate=0.1)
d = decoder(d, c1, filters=64, rate=0.1)

# Output
conv_out = Conv2D(3, kernel_size=3, padding='same', activation='sigmoid', name="Segmentator")(d)

# Model
model = Model(InputL, conv_out, name="UNet")
model.summary()

# Compile Model
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

BATCH_SIZE = 20
SPE = len(images)//BATCH_SIZE

def show_image(image, title=None):
    plt.imshow(image)
    plt.title(title)
    plt.axis('off')

class ShowProgress(Callback):
    def on_epoch_end(self, epoch, logs=None):
        id = np.random.randint(len(images))
        image = images[id]
        mask = label_maps[id]
        pred_mask = self.model(tf.expand_dims(image,axis=0))[0]

        plt.figure(figsize=(10,8))
        plt.subplot(1,3,1)
        show_image(image, title="Original Image")

        plt.subplot(1,3,2)
        show_image(mask, title="Original Mask")

        plt.subplot(1,3,3)
        show_image(pred_mask, title="Predicted Mask")

        plt.tight_layout()
        plt.show()

call_back = [ModelCheckpoint("UNet-Footbal-Player-Segmentation.h5", save_best_only=True),ShowProgress()]

model.fit(
   train_images,train_labels,
    validation_split=0.1,
    epochs=100,
    batch_size=BATCH_SIZE,
    steps_per_epoch=SPE,
    callbacks=call_back
)

prediction = model.predict(test_images)

def show_predections(test_images , prediction ,test_labels):

    for i in range(2):
        plt.figure(figsize=(10,8))
        plt.subplot(1,3,1)
        show_image(test_images[i], title="Original Image")

        plt.subplot(1,3,2)
        show_image(test_labels[i], title="Original Mask")

        plt.subplot(1,3,3)
        show_image(prediction[i], title="Predicted Mask")

        plt.tight_layout()
        plt.show()

show_predections(test_images , prediction ,test_labels)

model.save('model_footBall_segmentation')

